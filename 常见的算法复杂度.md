## 一、复杂度的比较

![](D:\Study\University\学习笔记\笔记截图资料\20210420144612.png)

从上表可以看出，O(n)、O(logn)、O(√n )、O(nlogn )随着n的增加，复杂度提升不大，因此这些复杂度属于效率高的算法，反观O(2ⁿ)和O(n!)当n增加到50时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，因此在动手编程时要评估所写算法的最坏情况的复杂度。

下面给出一个更加直观的图：

![](D:\Study\University\学习笔记\笔记截图资料\20210420144726.png)

> X - n值
>
> Y - T(n) 时间复杂度

常见的时间复杂度按照耗费的时间从小到大排序依次是：

>  O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

## 二、常见算法复杂度

| **算法**                     | **名称**                           | **复杂度**                                    | **备注**                     |
| ---------------------------- | ---------------------------------- | --------------------------------------------- | ---------------------------- |
| 快速排序                     | QuickSort(A,p,r)                   | 最坏：O(n2)平均：O(nlog n)均衡划分：O(nlog n) |                              |
| 合并排序                     | MergeSort(A,p,r)                   | O(nlog n)                                     |                              |
| 选最大                       | FindMax                            | O(n)                                          |                              |
| 选最大和最小                 | FindMaxMin                         | W(n)=3n/2-2=O(n)                              |                              |
| 找第二大                     | 锦标赛法                           | n+logn-2                                      |                              |
| 选择第k小                    | Select                             | O(n)                                          |                              |
| 动态规划：矩阵连乘           | MatrixChain(P,n)                   | 递归：O(2n)非递归：O(n3)                      |                              |
| 动态规划：投资问题           |                                    | O(nm2)                                        | m元钱投资n个项目             |
| 动态规划：背包问题           |                                    |                                               | 目标函数、约束条件、递推方程 |
| 动态规划：最长公共子序列     | LCS_length(X,Y)LCS(B,i,j)          | W(mn)=O(mn)S(mn)=O(mn)                        |                              |
| 动态规划：图像压缩           | Compress(P,n)                      | T(n)=O(n)                                     |                              |
| 动态规划：最大子段和         |                                    | 顺序：O(n3)分支策略：O(nlog n)动态规划：O(n)  |                              |
| 动态规划：凸多边形的三角划分 |                                    | 时间O(n3)，空间O(n2)                          |                              |
| 动态规划：电路布线           | MNS(C,n)                           | T(n)=O(n2)，S(n)=O(n2)                        |                              |
| 动态规划：最优二叉搜索树     |                                    | T(n)=O(n2)，S(n)=O(n2)                        |                              |
| 贪心法：活动选择问题         | Greedy Select                      |                                               |                              |
| 贪心法：最优装载问题         | Loading                            | O(nlogn)                                      |                              |
| 贪心法：最小延迟调度问题     |                                    | O(n)                                          |                              |
| 贪心法：找零钱问题           |                                    |                                               |                              |
| 贪心法：装箱问题             |                                    |                                               |                              |
| 贪心法：最优二元前缀码问题   | Huffman（C）                       | O(nlogn)                                      |                              |
| 贪心法：文件归并             | Huffman算法                        | O(nlogn)                                      |                              |
| 贪心法：最小生成树           | kruskal算法                        | O(nlogn)                                      |                              |
| 贪心法：单源最短路径         | Dijkstra算法                       | O(n2)                                         |                              |
| 回溯法：四后问题             | 递归回溯，迭代回溯四叉树，深度优先 | 指数级，蒙特卡罗法估计效率                    |                              |
| 回溯法：最有装载问题二       | 子集数，深度优先                   | 指数级                                        |                              |

> 我们去判断一个算法的复杂度是，要先明确n是谁

![](D:\Study\University\学习笔记\笔记截图资料\20210420145922.png)

![](D:\Study\University\学习笔记\笔记截图资料\20210420151343.png)

![](D:\Study\University\学习笔记\笔记截图资料\20210420151758.png)

**长度为n的二进制数字 --- O(2^n)**

* 该指数级别的时间复杂度是非常恐怖的，算法设计中应避免指数级别的复杂度。

**长度为n的数组的所有排列 --- O(n!)**

* 该阶乘级别的时间复杂度比指数级别的时间复杂度更恐怖

> 以上两种级别的复杂度，当 n < 20的时候，可能还能承受，一旦n > 20的时候就不建议这两种设计了！

![](https://gitee.com/liangsir-67/imagerepo/raw/master/img/20210420153218.png)

